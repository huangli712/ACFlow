#
# Project : Gardenia
# Source  : nac.jl
# Author  : Li Huang (huangli@caep.cn)
# Status  : Unstable
#
# Last modified: 2024/09/10
#

#
# Note:
#
# The following codes for the NevanAC solver are mostly adapted from
#
#     https://github.com/SpM-lab/Nevanlinna.jl
#
# See
#
#     Nevanlinna.jl: A Julia implementation of Nevanlinna analytic continuation
#     Kosuke Nogaki, Jiani Fei, Emanuel Gull, Hiroshi Shinaoka
#     SciPost Phys. Codebases 19 (2023)
#
# for more details. And we thank Dr. Shuang Liang for her help.
#

#=
### *Customized Structs* : *NevanAC Solver*
=#

"""
    NevanACContext

Mutable struct. It is used within the NevanAC solver only.

### Members
* G·µ•   -> Input data for correlator.
* grid -> Grid for input data.
* mesh -> Mesh for output spectrum.
* Œ¶    -> `Œ¶` vector in Schur algorithm.
* ùíú    -> Coefficients matrix `abcd` in Schur algorithm.
* ‚Ñã    -> Hardy matrix for Hardy basis optimization.
* ùëéùëè   -> Coefficients matrix for expanding `Œ∏` with Hardy basis.
* hmin -> Minimal value of the order of Hardy basis functions.
* hopt -> Optimal value of the order of Hardy basis functions.
"""
mutable struct NevanACContext
    G·µ•   :: Vector{APC}
    grid :: AbstractGrid
    mesh :: AbstractMesh
    Œ¶    :: Vector{APC}
    ùíú    :: Array{APC,3}
    ‚Ñã    :: Array{APC,2}
    ùëéùëè   :: Vector{C64}
    hmin :: I64
    hopt :: I64
end

#=
### *Global Drivers*
=#

"""
    solve(S::NevanACSolver, rd::RawData)

Solve the analytic continuation problem by the Nevanlinna analytical
continuation method.

### Arguments
* S -> A NevanACSolver struct.
* rd -> A RawData struct, containing raw data for input correlator.

### Returns
* mesh -> Real frequency mesh, œâ.
* Aout -> Spectral function, A(œâ).
* Gout -> Retarded Green's function, G(œâ).
"""
function solve(S::NevanACSolver, rd::RawData)
    println("[ NevanAC ]")
    #
    nac = init(S, rd)
    run(nac)
    Aout, Gout = last(nac)
    #
    return nac.mesh.mesh, Aout, Gout
end

"""
    init(S::NevanACSolver, rd::RawData)

Initialize the NevanAC solver and return a NevanACContext struct.

### Arguments
* S -> A NevanACSolver struct.
* rd -> A RawData struct, containing raw data for input correlator.

### Returns
* mec -> A NevanACContext struct.
"""
function init(S::NevanACSolver, rd::RawData)
    # Setup numerical precision. Note that the NAC method is extremely
    # sensitive to the float point precision.
    setprecision(128)

    # Convert the input data to APC, i.e., Complex{BigFloat}.
    œâ‚Çô = APC.(rd._grid * im)
    G‚Çô = APC.(rd.value)

    # Evaluate the optimal value for the size of input data.
    # Here we just apply the Pick criterion.
    ngrid = calc_noptim(œâ‚Çô, G‚Çô)

    # Prepera input data
    G·µ• = calc_mobius(-G‚Çô[1:ngrid])
    reverse!(G·µ•)
    println("Postprocess input data: ", length(G·µ•), " points")

    # Prepare grid for input data
    grid = make_grid(rd, T = APF)
    resize!(grid, ngrid)
    reverse!(grid)
    println("Build grid for input data: ", length(grid), " points")

    # Prepare mesh for output spectrum
    mesh = make_mesh(T = APF)
    println("Build mesh for spectrum: ", length(mesh), " points")

    # Precompute key quantities to accelerate the computation
    Œ¶, ùíú, ‚Ñã, ùëéùëè = precompute(grid, mesh, G·µ•)
    println("Precompute key matrices")

    # Actually, the NevanACContext struct already contains enough
    # information to build the Nevanlinna interpolant and get the
    # spectrum, but Hardy basis optimization is needed to smooth
    # the results further.
    return NevanACContext(G·µ•, grid, mesh, Œ¶, ùíú, ‚Ñã, ùëéùëè, 1, 1)
end

"""
    run(nac::NevanACContext)

Perform Hardy basis optimization to smooth the spectrum. the members `‚Ñã`,
`ùëéùëè`, `hmin`, and `hopt` of the NevanACContext struct (`nac`) should be
updated in this function.

### Arguments
* nac -> A NevanACContext struct.

### Returns
N/A
"""
function run(nac::NevanACContext)
    hardy = get_n("hardy")
    #
    if hardy
        println("Activate Hardy basis optimization")

        # Determine the minimal Hardy order (`hmin`), update `‚Ñã` and `ùëéùëè`.
        calc_hmin!(nac)

        # Determine the optimal Hardy order (`hopt`), update `‚Ñã` and `ùëéùëè`.
        calc_hopt!(nac)
    end
end

"""
    last(nac::NevanACContext)

Postprocess the results generated during the Nevanlinna analytical
continuation simulations.

### Arguments
* nac -> A NevanACContext struct.
"""
function last(nac::NevanACContext)
    # By default, we should write the analytic continuation results
    # into the external files.
    _fwrite = get_b("fwrite")
    fwrite = isa(_fwrite, Missing) || _fwrite ? true : false

    # Calculate full response function on real axis and write them
    # Note that _G is actually ùëÅG, so there is a `-` symbol for the
    # return value.
    _G = C64.(calc_green(nac.ùíú, nac.‚Ñã, nac.ùëéùëè))
    fwrite && write_complete(nac.mesh, -_G)

    # Calculate and write the spectral function
    Aout = F64.(imag.(_G) ./ œÄ)
    fwrite && write_spectrum(nac.mesh, Aout)

    # Regenerate the input data and write them
    kernel = make_kernel(nac.mesh, nac.grid)
    G = reprod(nac.mesh, kernel, Aout)
    fwrite && write_backward(nac.grid, G)

    return Aout, -_G
end

#=
### *Service Functions*
=#

#=
*Remarks* :

**Mobius transformation**

```math
\begin{equation}
z \mapsto \frac{z - i}{z + i}.
\end{equation}
```

It maps `z` from ``\overline{\mathcal{C}^{+}}`` to ``\overline{\mathcal{D}}``.
See `calc_mobius()`.

---

**Inverse Mobius transformation**

```math
\begin{equation}
z \mapsto i \frac{1 + z}{1 - z}.
\end{equation}
```

It maps `z` from ``\overline{\mathcal{D}}`` to ``\overline{\mathcal{C}^{+}}``.
See `calc_inv_mobius()`.

---

**Pick matrix**

```math
\begin{equation}
\mathcal{P} =
\left[
    \frac{1-\lambda_i \lambda^*_j}{1-h(Y_i)h(Y_j)^*}
\right]_{i,j}.
\end{equation}
```

Here, ``Y_i`` is the *i*th Matsubara frequency, ``C_i`` is the value of
``\mathcal{NG}`` at ``Y_i``, and ``\lambda_i`` is the value of ``\theta``
at ``Y_i``:

```math
\begin{equation}
\lambda_i = \theta(Y_i) = \frac{C_i - i}{C_i + i},
\end{equation}
```

```math
\begin{equation}
h(Y_i) = \frac{Y_i - i}{Y_i + i}.
\end{equation}
```

See `calc_pick()`.

---

**Œ¶ vector**

At first, we have

```math
\begin{equation}
\phi_{\alpha} = \theta_{\alpha}(Y_{\alpha}).
\end{equation}
```

So

```math
\begin{equation}
\phi_1 = \theta_1 (Y_1),
\end{equation}
```

```math
\begin{equation}
\phi_{\beta} =
\frac{-d_{\beta}\theta(Y_{\beta}) + b_{\beta}}{c_{\beta}\theta(Y_{\beta}) - \alpha_{\beta}}
\end{equation}
```

where

```math
\begin{equation}
\begin{pmatrix}
a_{\beta} & b_{\beta} \\
c_{\beta} & d_{\beta}
\end{pmatrix}
= \prod^{\beta-1}_{\alpha=1}
\begin{pmatrix}
\frac{Y_{\beta}-Y_{\alpha}}{Y_{\beta}-Y^*_{\alpha}} & \phi_{\alpha} \\
\phi^*_{\alpha}\frac{Y_{\beta} - Y_{\alpha}}{Y_{\beta} - Y^*_{\alpha}} & 1
\end{pmatrix},
\end{equation}
```

See `calc_phis()`.

---

**Contractive function Œ∏(z)**

```math
\begin{equation}
\theta(z)[z; Œ∏_{M+1}(z)] =
\frac{a(z)\theta_{M+1}(z) + b(z)}{c(z)\theta_{M+1}(z) + d(z)}
\end{equation}
```

where

```math
\begin{equation}
\begin{pmatrix}
a(z) & b(z) \\
c(z) & d(z)
\end{pmatrix}
= \prod^{M}_{j=1}
\begin{pmatrix}
\frac{z - Y_j}{z - Y^*_j} & \phi_j \\
\phi^*_j \frac{z - Y_j}{z - Y^*_j} & 1
\end{pmatrix}
\end{equation}
```

See `calc_abcd()` and `calc_theta()`.

---

**Hardy basis**

```math
\begin{equation}
f^k(z) = \frac{1}{\sqrt{\pi}(z + i)}
    \left( \frac{z - i}{z + i} \right)^k.
\end{equation}
```

See `calc_hbasis()` and `calc_hmatrix()`.

---

**Expanding ``\theta_{M+1}`` using Hardy basis**

```math
\theta_{M+1} = \sum^{H}_{k=0} \left[a_k f^k(z) + b_k f^k(z)^*\right]
```

See `calc_theta()`.

---

**Smooth norm**

```math
\begin{equation}
F[A_{\theta_{M+1}}(\omega)] =
    \left|
        1 - \int A_{\theta_{M+1}}(\omega) d\omega
    \right|^2 +
    \alpha \int \left[A^{''}_{\theta_{M+1}}(\omega)\right]^2 d\omega,
\end{equation}
```
where the first term enforces proper normalization while the second
term promotes smoothness by minimizing second derivatives. Here Œ±
is a regulation parameter.

See `smooth_norm()`.
=#

"""
    precompute(
        grid::AbstractGrid,
        mesh::AbstractMesh,
        G·µ•::Vector{APC}
    )

Precompute some key quantities, such as `Œ¶`, `ùíú`, `‚Ñã`, and `ùëéùëè`. Note
that `Œ¶` and `ùíú` won't be changed any more. But `‚Ñã` and `ùëéùëè` should be
updated by the Hardy basis optimization to get a smooth spectrum. Here
`G·µ•` is input data, `grid` is the grid for input data, and `mesh` is
the mesh for output spectrum.
"""
function precompute(
    grid::AbstractGrid,
    mesh::AbstractMesh,
    G·µ•::Vector{APC}
    )
    # Evaluate œï and `abcd` matrices
    Œ¶ = calc_phis(grid, G·µ•)
    ùíú = calc_abcd(grid, mesh, Œ¶)

    # Allocate memory for evaluating Œ∏
    # The initial Hardy order is just 1.
    ‚Ñã = calc_hmatrix(mesh, 1)
    ùëéùëè = zeros(C64, 2)

    return Œ¶, ùíú, ‚Ñã, ùëéùëè
end

"""
    calc_mobius(z::Vector{APC})

A direct Mobius transformation.
"""
function calc_mobius(z::Vector{APC})
    return @. (z - im) / (z + im)
end

"""
    calc_inv_mobius(z::Vector{APC})

An inverse Mobius transformation.
"""
function calc_inv_mobius(z::Vector{APC})
    return @. im * (one(APC) + z) / (one(APC) - z)
end

"""
    calc_pick(k::I64, ‚Ñé::Vector{APC}, Œª::Vector{APC})

Try to calculate the Pick matrix, anc check whether it is a positive
semidefinite matrix. See Eq. (5) in Fei's NAC paper.

### Arguments
* k -> Size of the Pick matrix.
* ‚Ñé -> Vector ‚Ñé. It is actually ùëß.
* Œª -> Vector Œª. It is actually ùí¢(ùëß).
"""
function calc_pick(k::I64, ‚Ñé::Vector{APC}, Œª::Vector{APC})
    pick = zeros(APC, k, k)

    # Calculate the Pick matrix
    for j = 1:k
        for i = 1:k
            num = one(APC) - Œª[i] * conj(Œª[j])
            den = one(APC) - ‚Ñé[i] * conj(‚Ñé[j])
            pick[i,j] = num / den
        end
        pick[j,j] += APC(1e-250)
    end

    # Cholesky decomposition
    return issuccess(cholesky(pick, check = false))
end

"""
    calc_phis(grid::AbstractGrid, G·µ•::Vector{APC})

Try to calculate the Œ¶ vector, which is used to calculate the ùíú matrix.
Note that Œ¶ should not be changed anymore once it has been established.

### Arguments
* grid -> Grid in imaginary axis for input Green's function.
* G·µ•   -> Input Green's function.
"""
function calc_phis(grid::AbstractGrid, G·µ•::Vector{APC})
    ngrid = length(grid)

    # Allocate memory
    Œ¶ = zeros(APC, ngrid)
    ùíú = zeros(APC, 2, 2, ngrid)
    ‚àè = zeros(APC, 2, 2)
    ùëî = grid.œâ * im

    # Initialize the `abcd` matrix
    for i = 1:ngrid
        ùíú[:,:,i] .= Matrix{APC}(I, 2, 2)
    end

    # Evaluate Œ¶ using recursive algorithm
    Œ¶[1] = G·µ•[1]
    for j = 1:ngrid-1
        for k = j+1:ngrid
            ‚àè[1,1] = ( ùëî[k] - ùëî[j] ) / ( ùëî[k] - conj(ùëî[j]) )
            ‚àè[1,2] = Œ¶[j]
            ‚àè[2,1] = conj(Œ¶[j]) * ‚àè[1,1]
            ‚àè[2,2] = one(APC)
            view(ùíú,:,:,k) .= view(ùíú,:,:,k) * ‚àè
        end
        num = ùíú[1,2,j+1] - ùíú[2,2,j+1] * G·µ•[j+1]
        den = ùíú[2,1,j+1] * G·µ•[j+1] - ùíú[1,1,j+1]
        Œ¶[j+1] = num / den
    end

    return Œ¶
end

"""
    calc_abcd(grid::AbstractGrid, mesh::AbstractMesh, Œ¶::Vector{APC})

Try to calculate the coefficients matrix abcd (here it is called ùíú),
which is then used to calculate Œ∏. See Eq. (8) in Fei's NAC paper.

### Arguments
* grid -> Grid in imaginary axis for input Green's function.
* mesh -> Real frequency mesh.
* Œ¶    -> Œ¶ vector calculated by `calc_phis()`.
"""
function calc_abcd(grid::AbstractGrid, mesh::AbstractMesh, Œ¶::Vector{APC})
    eta::APF = get_n("eta")

    ngrid = length(grid)
    nmesh = length(mesh)

    ùëî = grid.œâ * im
    ùëö = mesh.mesh .+ im * eta

    ùíú = zeros(APC, 2, 2, nmesh)
    ‚àè = zeros(APC, 2, 2)

    for i = 1:nmesh
        result = Matrix{APC}(I, 2, 2)
        ùëß = ùëö[i]
        for j = 1:ngrid
            ‚àè[1,1] = ( ùëß - ùëî[j] ) / ( ùëß - conj(ùëî[j]) )
            ‚àè[1,2] = Œ¶[j]
            ‚àè[2,1] = conj(Œ¶[j]) * ‚àè[1,1]
            ‚àè[2,2] = one(APC)
            result *= ‚àè
        end

        ùíú[:,:,i] .= result
    end

    return ùíú
end

"""
    calc_hbasis(z::APC, k::I64)

Try to calculate the Hardy basis ``f^k(z)``.

### Arguments
* z -> A complex variable.
* k -> Current order for the Hardy basis.
"""
function calc_hbasis(z::APC, k::I64)
    w = ( z - im ) / ( z + im )
    return 1.0 / ( sqrt(œÄ) * (z + im) ) * w^k
end

"""
    calc_hmatrix(mesh::AbstractMesh, H::I64)

Try to calculate ``[f^k(z), f^k(z)^*]`` for 0 ‚â§ ùëò ‚â§ ùêª-1, which is
called the hardy matrix (‚Ñã) and is used to evaluate Œ∏‚Çò‚Çä‚ÇÅ.

### Arguments
* mesh -> Real frequency mesh.
* H    -> Maximum order for the Hardy basis.
"""
function calc_hmatrix(mesh::AbstractMesh, H::I64)
    # Build real axis
    eta::APF = get_n("eta")
    ùëö = mesh.mesh .+ eta * im

    # Allocate memory for the Hardy matrix
    nmesh = length(mesh)
    ‚Ñã = zeros(APC, nmesh, 2*H)

    # Build the Hardy matrix
    for k = 1:H
        ‚Ñã[:,2*k-1] .= calc_hbasis.(ùëö,k-1)
        ‚Ñã[:,2*k]   .= conj(‚Ñã[:,2*k-1])
    end

    return ‚Ñã
end

"""
    calc_theta(ùíú::Array{APC,3}, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})

Try to calculate the contractive function Œ∏(z). ùíú is the coefficients
matrix abcd, ‚Ñã is the Hardy matrix, and ùëéùëè are complex coefficients
for expanding Œ∏‚Çò‚Çä‚ÇÅ. See Eq. (7) in Fei's NAC paper.

### Arguments
* ùíú  -> Matrix ùëéùëèùëêùëë.
* ‚Ñã  -> Hardy matrix.
* ùëéùëè -> Expansion coefficients ùëé and ùëè for the contractive function Œ∏.
"""
function calc_theta(ùíú::Array{APC,3}, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})
    # Well, we should calculate Œ∏‚Çò‚Çä‚ÇÅ at first.
    Œ∏‚Çò‚Çä‚ÇÅ = ‚Ñã * ùëéùëè

    # Then we evaluate Œ∏ according Eq. (7)
    num = ùíú[1,1,:] .* Œ∏‚Çò‚Çä‚ÇÅ .+ ùíú[1,2,:]
    den = ùíú[2,1,:] .* Œ∏‚Çò‚Çä‚ÇÅ .+ ùíú[2,2,:]
    Œ∏ = num ./ den

    return Œ∏
end

"""
    calc_green(ùíú::Array{APC,3}, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})

Firstly we try to calculate Œ∏. Then Œ∏ is back transformed to a Nevanlinna
interpolant via the inverse Mobius transform. Here, `ùíú` (`abcd` matrix),
`‚Ñã` (Hardy matrix), and `ùëéùëè` are used to evaluate Œ∏.

### Arguments
* ùíú  -> Matrix ùëéùëèùëêùëë.
* ‚Ñã  -> Hardy matrix.
* ùëéùëè -> Expansion coefficients ùëé and ùëè for the contractive function Œ∏.
"""
function calc_green(ùíú::Array{APC,3}, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})
    Œ∏ = calc_theta(ùíú, ‚Ñã, ùëéùëè)
    gout = calc_inv_mobius(Œ∏)

    return gout
end

"""
    calc_noptim(œâ‚Çô::Vector{APC}, G‚Çô::Vector{APC})

Evaluate the optimal value for the size of input data (how may frequency
points are actually used in the analytic continuation simulations) via
the Pick criterion.

### Arguments
* œâ‚Çô -> Matsubara frequency points (the ùëñ unit is not included).
* G‚Çô -> Matsubara Green's function.
"""
function calc_noptim(œâ‚Çô::Vector{APC}, G‚Çô::Vector{APC})
    # Get size of input data
    ngrid = length(œâ‚Çô)

    # Check whether the Pick criterion is applied
    pick = get_n("pick")
    if !pick
        return ngrid
    end

    # Apply invertible Mobius transformation. We actually work at
    # the \bar{ùíü} space.
    ùìè = calc_mobius(œâ‚Çô)
    ùí¢ = calc_mobius(-G‚Çô)

    # Find the optimal value of k until the Pick criterion is violated
    k = 0
    success = true
    while success && k ‚â§ ngrid
        k += 1
        success = calc_pick(k, ùìè, ùí¢)
    end

    # Return the optimal value for the size of input data
    if !success
        println("The size of input data is optimized to $(k-1)")
        return k - 1
    else
        println("The size of input data is optimized to $(ngrid)")
        return ngrid
    end
end

"""
    calc_hmin!(nac::NevanACContext)

Try to perform Hardy basis optimization. Such that the Hardy matrix ‚Ñã
and the corresponding coefficients ùëéùëè are updated. They are used to
calculate Œ∏, which is then back transformed to generate smooth G (i.e.,
the spectrum) at real axis.

This function will determine the minimal value of H (hmin). Of course,
‚Ñã and ùëéùëè in NevanACContext struct are also changed.
"""
function calc_hmin!(nac::NevanACContext)
    hmax = get_n("hmax")

    h = 1
    while h ‚â§ hmax
        println("H (Order of Hardy basis) -> $h")

        # Prepare initial ‚Ñã and ùëéùëè
        ‚Ñã = calc_hmatrix(nac.mesh, h)
        ùëéùëè = zeros(C64, 2*h)

        # Hardy basis optimization
        causality, optim = hardy_optimize!(nac, ‚Ñã, ùëéùëè, h)

        # Check whether the causality is preserved and the
        # optimization is successful.
        if causality && optim
            nac.hmin = h
            break
        else
            h = h + 1
        end
    end
end

"""
    calc_hopt!(nac::NevanACContext)

Try to perform Hardy basis optimization. Such that the Hardy matrix ‚Ñã
and the corresponding coefficients ùëéùëè are updated. They are used to
calculate Œ∏, which is then back transformed to generate smooth G (i.e.,
the spectrum) at real axis.

This function will determine the optimal value of H (hopt). Of course,
‚Ñã and ùëéùëè in NevanACContext struct are also changed.
"""
function calc_hopt!(nac::NevanACContext)
    hmax = get_n("hmax")

    for h = nac.hmin + 1:hmax
        println("H (Order of Hardy basis) -> $h")

        # Prepare initial ‚Ñã and ùëéùëè
        ‚Ñã = calc_hmatrix(nac.mesh, h)
        ùëéùëè  = copy(nac.ùëéùëè)
        push!(ùëéùëè, zero(C64))
        push!(ùëéùëè, zero(C64))
        @assert size(‚Ñã)[2] == length(ùëéùëè)

        # Hardy basis optimization
        causality, optim = hardy_optimize!(nac, ‚Ñã, ùëéùëè, h)

        # Check whether the causality is preserved and the
        # optimization is successful.
        if !(causality && optim)
            break
        end
    end
end

"""
    hardy_optimize!(
        nac::NevanACContext,
        ‚Ñã::Array{APC,2},
        ùëéùëè::Vector{C64},
        H::I64
    )

For given Hardy matrix ‚Ñã, try to update the expanding coefficients ùëéùëè
by minimizing the smooth norm.

### Arguments
* nac -> A NevanACContext struct.
* ‚Ñã   -> Hardy matrix, which contains the Hardy basis.
* ùëéùëè  -> Expansion coefficients ùëé and ùëè for the contractive function Œ∏.
* H   -> Maximum order of the Hardy basis.
"""
function hardy_optimize!(
    nac::NevanACContext,
    ‚Ñã::Array{APC,2},
    ùëéùëè::Vector{C64},
    H::I64
    )
    # Function call to the smooth norm.
    function ùëì(x::Vector{C64})
        return smooth_norm(nac, ‚Ñã, x)
    end

    # Function call to the gradient of the smooth norm.
    #
    # Here we adopt the Zygote package, which implements an automatic
    # differentiation algorithm, to evaluate the gradient of the smooth
    # norm. Of course, we can turn to the finite difference algorithm,
    # which is less efficient.
    function ùêΩ!(J::Vector{C64}, x::Vector{C64})
        #J .= Zygote.gradient(ùëì, x)[1]

        # Finite difference algorithm
        J .= gradient_via_fd(ùëì, x)
    end

    # Perform numerical optimization by the BFGS algorithm.
    # If it is failed, please turn to the Optim.jl package.
    # A simplified version is implemented in math.jl.
    res = optimize(ùëì, ùêΩ!, ùëéùëè, max_iter = 500)

    # Check whether the BFGS algorithm is converged
    if !converged(res)
        @info("Sorry, faild to optimize the smooth norm!")
    end

    # Check causality of the solution
    causality = check_causality(‚Ñã, res.minimizer)

    # Update ‚Ñã and the corresponding ùëéùëè
    if causality && (converged(res))
        nac.hopt = H
        nac.ùëéùëè = res.minimizer
        nac.‚Ñã = ‚Ñã
    end

    return causality, converged(res)
end

"""
    smooth_norm(nac::NevanACContext, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})

Establish the smooth norm, which is used to improve the smoothness of
the output spectrum.

### Arguments
* nac -> A NevanACContext struct.
* ‚Ñã   -> Hardy matrix, which contains the Hardy basis.
* ùëéùëè  -> Expansion coefficients ùëé and ùëè for the contractive function Œ∏.
"""
function smooth_norm(nac::NevanACContext, ‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})
    # Get regulation parameter
    Œ± = get_n("alpha")

    # Generate output spectrum
    _G = calc_green(nac.ùíú, ‚Ñã, ùëéùëè)
    A = F64.(imag.(_G) ./ œÄ)

    # Normalization term
    ùëì‚ÇÅ = trapz(nac.mesh, A)

    # Smoothness term
    sd = second_derivative(nac.mesh.mesh, A)
    x_sd = nac.mesh.mesh[2:end-1]
    ùëì‚ÇÇ = trapz(x_sd, abs.(sd) .^ 2)

    # Assemble the final smooth norm
    ùêπ = abs(1.0 - ùëì‚ÇÅ)^2 + Œ± * ùëì‚ÇÇ

    return F64(ùêπ)
end

"""
    check_pick(wn::Vector{APC}, gw::Vector{APC}, Nopt::I64)

Check whether the input data are valid (the Pick criterion is satisfied).
Here, `wn` is the Matsubara frequency, `gw` is the Matsubara function,
and `Nopt` is the optimized number of Matsubara data points.
"""
function check_pick(wn::Vector{APC}, gw::Vector{APC}, Nopt::I64)
    freq = calc_mobius(wn[1:Nopt])
    val = calc_mobius(-gw[1:Nopt])

    success = calc_pick(Nopt, val, freq)
    #
    if success
        println("Pick matrix is positive semi-definite.")
    else
        println("Pick matrix is non positive semi-definite matrix in Schur method.")
    end
end

"""
    check_causality(‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})

Check causality of the Hardy coefficients `ùëéùëè`.
"""
function check_causality(‚Ñã::Array{APC,2}, ùëéùëè::Vector{C64})
    Œ∏‚Çò‚Çä‚ÇÅ = ‚Ñã * ùëéùëè

    max_theta = findmax(abs.(Œ∏‚Çò‚Çä‚ÇÅ))[1]

    if max_theta <= 1.0
        println("max_theta = ", max_theta)
        println("Hardy optimization was success.")
        causality = true
    else
        println("max_theta = ", max_theta)
        println("Hardy optimization was failure.")
        causality = false
    end

    return causality
end
